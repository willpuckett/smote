---
title: "Typelording with Fauna and Fresh"
tags: [ deno, fresh, fauna, webdev ]
publish_date: 2023-02-10

---

A few weeks ago, I started playing with using Fauna along with the Fresh
framework. The purportedly global nature of Fauna seems to be a natural paring
with Deno deploy. I'm not a database person, and I want someone to do it for me,
which Fauna kind of does well.

I found
[this tutorial](https://dev.to/shadid12/building-a-full-stack-app-with-deno-fresh-and-fauna-223p)
really useful for seeing how to handle session with Fauna, and I was kind of off
to the races, so I thought. As I got to know the database better, I realized
that many of the functions I was writing as API endpoints in Fresh could be
autogenerated if I simply uploaded a GraphQL schema to Fauna.

The best tutorial I found for getting started with Fauna and GraphQL was
[here](https://graphql-workshop.vercel.app). It covers building authentication
and login with GraphQL.
[This tutorial](https://seanconnolly.dev/simple-graphql-with-faunadb) was really
useful for setting up a kind of local copy of everything Fauna in my editor. (I
was able to initalize it with `deno run -A npm:fauna-gql-upload init`, but I had
to use npx to actually push to Fauna.)

All this left me in a little bit of a connundrum though, because I was defining
a whole schema in GraphQL and then again in TypeScript. I sensed that someone
must have dealt with this before, and I began to search. I pretty immediately
happened on graphql-codegn, but I had a really difficult time getting it to run
in Deno and output the declartions I wanted. All of the instructions for codegen
wanted me to install a bunch of things, and esm.sh wasn't importing things well
due usually to dependencies missing default exports (yargs and depgraph
specifically).

Eventually, I came up with this:

```typescript
// import "https://esm.sh/graphql@16.6.0" // This turned out not to be necessary
import { CodegenConfig, executeCodegen } from "npm:@graphql-codegen/cli"
import "npm:@graphql-codegen/typescript"

// Of interest for further exploration
// import 'npm:@graphql-codegen/typescript-type-graphql'
// import 'npm:graphql-codegen-typescript-validation-schema'

// Not at all necessary for my project, although maybe I'm just displaying my ignorance
// import "npm:@graphql-codegen/client-preset"

const config: CodegenConfig = {
  overwrite: true,
  schema: "./fauna/**/*.gql",
  emitLegacyCommonJSImports: false,
  // documents: "src/**/*.tsx",
  generates: {
    "./fauna/": {
      plugins: ["typescript"],
      // preset: "client"
      config: {
        declarationKind: "declare interface",
        // enumsAsTypes: true,
        noExport: true,
        typesPrefix: "I",
        skipTypename: true,
        //  ignoreEnumValuesFromSchema: true,
      },
    },
  },
}

// This isn't really necessary either. It was useful when I was generating the client code since it wants to make multiple files.
const paths = Object.keys(config.generates)
paths.map(async (p) => {
  await Deno.mkdir(
    `${p.slice(-1) === "/" ? p : p.split("/").slice(0, -1).join("/")}`,
    { recursive: true },
  )
})

const outputs = await executeCodegen(config)

// The .map isn't really necessary for a single .d.ts file since you could just call writeTextFile with the array position of the arguments, but it was useful when I was generating the client code so I left it incase I decide I need to again in the future.
outputs.map(async (glob) => {
  await Deno.writeTextFile(
    `${glob.filename}${glob.filename.slice(-1) === "/" ? "types.d.ts" : ""}`,
    // `declare global {\n${glob.content}\n}`,
    glob.content,
  )
})
```

Then, in `deno.json`, I added a task to run codegen and, the real magic, the
type declaration file (types.d.ts generated by codegen) to the
`compilerOptions.types` array:

```typescript
{
  "tasks": {
    "start": "deno run -A --watch=static/,routes/ dev.ts",
    "mail": "deno run -A mail/main.ts",
    "codegen": "deno run -A fauna/codegen.ts && deno fmt ./fauna/",
    "fauna-push": "npx fauna-gql-upload upload",
    "fauna-init": "deno npm:fauna-gql-upload init"
  },
  "compilerOptions": {
    "jsx": "react-jsx",
    "jsxImportSource": "preact",
    "types": [
      "./fauna/types.d.ts"
    ]
  },
  "importMap": "./import_map.json",
  "fmt": {
    "options": {
      "singleQuote": true,
      "semiColons": false
    }
  }
}
```

I'm not really sure if I did this the right way. It seems like using `types.ts`
is more common, although that usually just exports a bunch of types that then
need to get imported into the relavent files. I could see TypeScript choking out
on a really large project with a bunch of types, but since my project was pretty
small with a a small number of types that were imported very pervasively
thorughout the project, it seemed to make the most sense to `declare` them and
then make them available everywhere all at once.

Project [repo](https://github.com/willpuckett/fauna-graphql-codegen).
